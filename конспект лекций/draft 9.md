# в предыдущих сериях
ранее использовали от спринга
mvc
spring core (отвечал за жизненный цикл бинов?) -- мы лишь расставляли аннотации, и после не использовали слово new чтобы создавать объекты а считали что спринг сам за нас их создаст когда надо будет (синглтоны) и пропихнет нужные зависимости -- это был IoC
частный случай IoC это DI
в основном мы его (ди) осуществляли через параметры конструкторов
это упрощает в частности вещи связанные с тестированием
иногда можем и через properties аннотацией autowired ???
использовали validation , jpa

теперь

будет больше абстракций, взаимосвязи между объектами предметной области

# виды взаимосвязей
грубо говоря есть 4 способа как сущности могут быть взаимосвязаны:
`<many/one>-to-<many/one>`
для `one-to-one` `one-to-man`y чтобы хранить информацию достаточно поставить какую-нибудь колоночку (или две)
чтобы хранить `many-to-many` энивей придется завести отдельную таблицу
#### примеры
пользователи (как авторы) -- посты = `one-to-many`
посты -- пользователи = `many-to-one`
юзер -- социальная информация = `one-to-one`
юзеры -- группы юзеров = `many-to-many`
# практика
![[Pasted image 20240307124503.png|350]]
что означает:
у объекта `Post` есть мэппинг many-to-one с `User`
и осуществлять этот мэппинг нужно через дополнительную колонку с именем `user_id`

![[Pasted image 20240307124924.png]]
что означает:
отображение осуществляется обратно через объект `user`

![[Pasted image 20240307134222.png]]
дополнительная таблица `user_role` , имена колонок
#### делаем аннотацию guest
![[Pasted image 20240307130747.png|275]]
"не нужно удалят эту аннотацию после компиляции, она нужна будет в рантайме"
"аннотация на методы"

![[Pasted image 20240307130906.png|245]]
ставим ее вот в таких местах
#### interceptor
interceptor -- типа фильтра будет перехватывать доступ к методам там и т п

![[Pasted image 20240307131732.png]]
мы заставим этот класс всегда когда дергаем какой-то метод из Page (нашего контроллера) вызываться

![[Pasted image 20240307133500.png|425]]
![[Pasted image 20240307133430.png|425]]
если мы поймали метод
-> если метод определяется из `Page`
--> если нет аннотации `@Guest`
---> залетаем в `indexPage` *(но в проде так делать не надо)*, используем его функцию `getUser(request)` и смотрим залогинен ли юзер, возвращаем `true` или `false`
#Note сам `request`,` request.getSession()` у нас есть итак, мы обращаемся к `indexPage` только чтобы она по сути распарсила данные и посмотрела для нас в них Юзер сессию.


`true` если все ок, можно передавать процесс обработки дальше в цепочку 
`false` -- вызов штуки не будет осуществляться
ну короче прям литералли фильтр просто в других цепочках обработки
#### донастройка interceptor-а
![[Pasted image 20240307133753.png]]
вот она
вроде  типа добавляем интерцептор в регистр всего

#### делаем роли
через аннотации и бд
есть доменный объект `Role` со связями` many-to-many`  с юзерами
![[Pasted image 20240307134757.png|300]]
аннотация

![[Pasted image 20240307134842.png|241]]
расставляем аннотацию

и прокачиваем интерцептор

еще там какую то штуку в юзер сервисе пишем чтобы ьона проверяла что все роли есть в бд?

#### про ленивость
если есть мэппинг `чтото-to-many` то используются коллекции которые не хочется доставать на каждый чих поэтому достаются они всегда лениво, по требованию (on demand)
это приводит к тому что в пользователе которого мы достали из бд и который отображается как экземпляр класса нет готового списка постов есть только что-то типа динамического прокси который при попытке обращения к соответствующему геттеру подгрузит посты
такова стратегия по умолвчанию
SecurityInterceptor живет в не совсем обычный момент жизни приложения, и в нем подключение к бд находится в несколько другом состоянии нежели в момент жизни контроллеров и поэтому нельзя порезолвить ленивость
как фиксится:
указываем стратегию чтобы сет ролей всегда сразу доставался
![[Pasted image 20240307141551.png|300]]


![[Pasted image 20240307132450.png]]
правило трех сигм
#### note про DI
видимо классический DI: 
![[Pasted image 20240307132529.png|375]]
он [здесь](https://youtu.be/czFo3DHZTB4?list=PLd7QXkfmSY7ZAwa6z9rNEHBRfHGeLCXS7&t=3437) примерно это сказал

# итог
по сути в этом занятии глубже познакомились с JPA
вспомнили отношения между парами объектов и как мы можем их декларативно размечать

	не структурированно
http -- протокол прикладного уровня, на котором упрощенно говоря общаются браузер и веб сервер. это протокол предметной области -- он знает что такое web, какие атрибуты(свойства) есть у запросов и у ответов
http пакет заворачивается в tcp пакет
протокол в более нижнего уровня
самый верхний (дня нас) уровень -- http
https = http завернутый в tls чтобы шифровать (открытым\\закрытым ключом сервера)
Отец основатель веба -- Тим Бернер-Ли (CERN) , первый сайт info.cern.ch 6 августа 1991
![[Pasted image 20240206161810.png]]

сервер и клиент(пользовательский агент) обмениваются запросами и ответами на них (requests and responds) 
начиная с хттп2 протокол усложнился но основная часть общения происходит по такой схеме:
пользовательский user-agent посылает запрос "дай мне (или получи лот меня) такие то данные" -- и сервер отвечает(получает) этими данными

## HTTP
![[Pasted image 20240206162502.png]]
TCP -- протокол с помощью которого сетевые интерфейсы взаимодействуют между собой устанавливая надежное (reliable-)соединение
это делается трехвазным рукопожатием во время установки соединения -- небыстрая тема

**кажется**
когда был хттп 1.0 предполагалось что для каждого документа который клиент хочет скачать с сервера (ну т е для каждого запроса) используется свое соединение т е устанавливается с нуля tcp соединение мы просим сервер дает и соединение закрывается
очевидно долгая ресурсоемкая хуйня поэтому в 1.1 был придуман keep-alive концепция -- когда user-agent устанавливает соединение с сервером и может не разрывать его и уже в рамках этого соединения можно посылать много реквестов респонсов
кип-элайвы не бесконечны -- обычно 10ки-100ни секунд
TLS -- типа шифрованный TCP

когда мы говорим tcp\\ip нужно понимать что протокол ip более низкий чем tcp
"пакеты tcp уложены в протокол ip" 

все выше хттп -- **в основном** ( #проверить) для отображения запрошенного контента

##### http -- протокол прикладного уровня, предметной области
примеры других протоколов прикладного уровня: ssh -- "присоединяемся к серверу" , smtp
"клиент-серверный протокол, запрос-ответ ориентированный"
разделение клиент\\сервер есть не во всех протоколах

stateless -- не интересует история
**состояние закодировано в запросе** (вспоминаем reqest.getAttribute())

## URI и URL
![[Pasted image 20240206164730.png]]
картинка -- **УРЛ**
"унифицированный локатор ресурсов" , местоположение ресурсов в интернете
будем обращаться к базам данных и вместо foo будет mysql или jdbc 
может быть ssh
порт это tcp порт 
для http дефолтный порт это 80
https -- 443
путь -- case-sensitive, а схема и хостнэйм **вроде** нет

параметры у запроса (своего рода) бывают 2х видов:
1. get-параметры -- которые содержатся в get строке -- используются в основном для гет запросов -- могут быть доступны и видны промежуточным прокси-серверам, попадают в логи
2. которые находятся в самом запросе лол
fragment: после решетки -- определенный кусок на странице куда проскроллить
обычно не передается на сервер


URI это в принципе концепция , объединение URL и URN
URN это концепция идентификатора имени, например isbn (urn:isbn:5170224575), *впринципе это нам знать не надо*
### особенности (слайд)
![[Pasted image 20240206181500.png]]
например русские символы будут кодироваться через "процентное" кодирование

## практичим
neerc.ifmo.ru -- хост
чтобы установить tcp соединение по сокету
сокет это конечная точка соединения
нам нужны 2 вещи -- ip адресс и номер порта
ip адрес вполне определяется по хост-нейму с помощью протокола dns (это суть этого протокола)

```
> ping neerc.ifmo.ru

64 bytes from neerc.ifmo.ru (77.234.215.132): icmp_seq=1 ttl=56 time=30.2 ms
64 bytes from neerc.ifmo.ru (77.234.215.132): icmp_seq=2 ttl=56 time=27.5 ms
64 bytes from neerc.ifmo.ru (77.234.215.132): icmp_seq=3 ttl=56 time=27.5 ms
^C
--- neerc.ifmo.ru ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 27.460/28.398/30.200/1.274 ms

```
кстати на компе есть?бывает? файлик hosts где браузер может сначала поискать нужный ip для текстого представления хоста
т о на разработке для несуществующего хоста можно вбить сайт -> 127.0.0.1 и типа вот)
кажется в \\etc\\hosts

telnet -- tcp хуйня

## как выглядит HTTP запрос
![[Pasted image 20240206183504.png]]

GET POST  и т п -- методы http запроса
get значит что мы хотим запросить данные -- типа read-only запрос
post -- отправить данные
версия протокола прописывается например чтобы делать обратную совместимость

сайтов в мире больше чем серверов так что один сервер может держать несколько сайтов
обязательные -- первые две строки и пустая строка как конец запроса

## пример ответа
![[Pasted image 20240206185545.png]]
302 -- статусный код
	код ответа:
	первая цифра от 1 до 5
	302 -- редирект
	200 -- ОК
после заголовков пустая строка и тело ответа


заметка:
ответ на фото нам вернул  реверс-прокси сервера, который стоит перед сервером
nginx это легковесный реверс-прокси 
зачастую версию сервера(или реверс-прокси) скрывают чтобы было сложнее ломать

![[Pasted image 20240206185838.png]]
еще один пример запроса

поговорили про заголовки
**Accept**: формат "группа/подгруппа" + веса всякие... пример: text/html
**Accept-Encoding**: алгоритмы сжатия(компрессии) которые "браузер" использует
Accept-language понятно что
Connection: keep-alive
user-agent: например какой браузер какой версии используешь
ответ (что не видели):
![[Pasted image 20240206190619.png]]
![[Pasted image 20240206190657.png]] -- не всегда используется (вдруг мы что-то большое и непонятное по размеру и не сразу передаем типа видео?)
![[Pasted image 20240206190848.png]]  -- куда произошел редирект

![[Pasted image 20240206191056.png]] -- для хэширования, сокращения трафика

![[Pasted image 20240206191709.png]]

referer -- кто инициировал запрос

![[Pasted image 20240206191817.png]]
то, какая семантика вкладывается в запрос
**RO** = **read-only**= не меняет (состояние и что либо) сервера и идемпотент самим протоколом никак не проверяются (и не могут), но лучше их как бы да

![[Pasted image 20240206192355.png]]
![[Pasted image 20240206192556.png]]

![[Pasted image 20240206192737.png]] -- статусные коды
307, 308 -- браузер обязан при редиректе повторять полностью свой запрос
503 -- пока ниче не работает но так и надо

хранящиеся куки отсылаются при всех запросах на данный хост
по сути куки как бы хранят сессию
можно указывать skope? -- где кука применима (например мы хотим чтобы codeforces.com и polygon.codeforces.com были разными)
httponly -- ну типа что javascript код не имеет доступа к этой куке
secure -- запрещаем передавать по http (понятно почему)

## cache-control (слайд)
![[Pasted image 20240206194452.png]]
прокси-кэширование (не на user-agent-е) возможно (в основном?) только при http по понятным причинам
![[Pasted image 20240206194744.png]]
server push -- передача документов в клиент, инициированная сервером?
мультиплексирование -- в рмаках одного tcp соединения параллельная скачка? теперь нет очереди запрос-ответов...




### погуглить про:
**реверс-прокси, прокси-сервер**
TCP, TLS
UDP, DNS
отличия TCP и UDP
keep-alive
ssh, smtp
http3
